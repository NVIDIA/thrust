<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>thrust: Stream Compaction</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Stream Compaction<br>
<small>
[<a class="el" href="group__reordering.html">Reordering</a>]</small>
</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Namespaces</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacethrust_1_1experimental.html">thrust::experimental</a></td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ForwardIterator, typename Predicate&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">ForwardIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stream__compaction.html#g0c4bd59a85f63ec0d17f579e92fc333e">thrust::partition</a> (ForwardIterator first, ForwardIterator last, Predicate pred)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ForwardIterator, typename Predicate&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">ForwardIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stream__compaction.html#gf7f5925c861f229d1a059bb03f00ff16">thrust::stable_partition</a> (ForwardIterator begin, ForwardIterator end, Predicate pred)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ForwardIterator, typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">ForwardIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stream__compaction.html#gee39ef07b42f5d17b453e409f7f9b315">thrust::remove</a> (ForwardIterator first, ForwardIterator last, const T &amp;value)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator, typename OutputIterator, typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">OutputIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stream__compaction.html#ge94994f9049c44a4298dcf2c6ceb2514">thrust::remove_copy</a> (InputIterator first, InputIterator last, OutputIterator result, const T &amp;value)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ForwardIterator, typename Predicate&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">ForwardIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stream__compaction.html#g517b17ceafe31a9fc70ac5127bd626de">thrust::remove_if</a> (ForwardIterator first, ForwardIterator last, Predicate pred)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator, typename OutputIterator, typename Predicate&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">OutputIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stream__compaction.html#g0dd1a702821e89b3369c7ae0d3f45af7">thrust::remove_copy_if</a> (InputIterator first, InputIterator last, OutputIterator result, Predicate pred)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ForwardIterator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">ForwardIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stream__compaction.html#g330c12555aa9d382254c9f1296e3edcc">thrust::unique</a> (ForwardIterator first, ForwardIterator last)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ForwardIterator, typename BinaryPredicate&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">ForwardIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stream__compaction.html#ga213c713ba882275d7f98564528bc4ab">thrust::unique</a> (ForwardIterator first, ForwardIterator last, BinaryPredicate binary_pred)</td></tr>

</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g0c4bd59a85f63ec0d17f579e92fc333e"></a><!-- doxytag: member="thrust::partition" ref="g0c4bd59a85f63ec0d17f579e92fc333e" args="(ForwardIterator first, ForwardIterator last, Predicate pred)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator, typename Predicate&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ForwardIterator thrust::partition           </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&nbsp;</td>
          <td class="paramname"> <em>pred</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>partition</code> reorders the elements <code>[first, last)</code> based on the function object <code>pred</code>, such that all of the elements that satisfy <code>pred</code> precede the elements that fail to satisfy it. The postcondition is that, for some iterator <code>middle</code> in the range <code>[first,last)</code>, <code>pred(*i)</code> is <code>true</code> for every iterator <code>i</code> in the range <code>[first,middle)</code> and <code>false</code> for every iterator <code>i</code> in the range <code>[middle,last)</code>. The return value of <code>partition</code> is <code>middle</code>.<p>
Note that the relative order of elements in the two reordered sequences is not necessarily the same as it was in the original sequence. A different algorithm, <a class="el" href="group__stream__compaction.html#gf7f5925c861f229d1a059bb03f00ff16">stable_partition</a>, does guarantee to preserve the relative order.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>The beginning of the sequence to reorder. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>last</em>&nbsp;</td><td>The end of the sequence to reorder. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pred</em>&nbsp;</td><td>A function object which decides to which partition each element of the sequence <code>[begin,end)</code> belongs. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An iterator referring to the first element of the second partition, that is, the sequence of the elements which do not satisfy <code>pred</code>.</dd></dl>
<dl compact><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ForwardIterator</em>&nbsp;</td><td>is a model of <a href="http://www.sgi.com/tech/stl/ForwardIterator.html">Forward Iterator</a>, and <code>ForwardIterator's</code> <code>value_type</code> is convertible to <code>Predicate's</code> <code>argument_type</code>, and <code>ForwardIterator</code> is mutable. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Predicate</em>&nbsp;</td><td>is a model of <a href="http://www.sgi.com/tech/stl/Predicate.html">Predicate</a>.</td></tr>
  </table>
</dl>
The following code snippet demonstrates how to use <code>partition</code> to reorder a sequence so that even numbers precede odd numbers.<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;<a class="code" href="partition_8h.html" title="Defines the interface to a function performing a stream compaction computation.">thrust/partition.h</a>&gt;</span>
  ...
  <span class="keyword">struct </span>is_even
  {
    __host__ __device__
    <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> <span class="keywordtype">int</span> &amp;x)
    {
      <span class="keywordflow">return</span> (x % 2) == 0;
    }
  };
  ...
  <span class="keywordtype">int</span> A[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
  <span class="keyword">const</span> <span class="keywordtype">int</span> N = <span class="keyword">sizeof</span>(A)/<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>);
  <a class="code" href="group__stream__compaction.html#g0c4bd59a85f63ec0d17f579e92fc333e">thrust::partition</a>(A, A + N,
                     is_even());
  <span class="comment">// A is now {2, 4, 6, 8, 10, 1, 3, 5, 7, 9}</span>
</pre></div><p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a href="http://www.sgi.com/tech/stl/partition.html">http://www.sgi.com/tech/stl/partition.html</a> <p>
<code><a class="el" href="group__stream__compaction.html#gf7f5925c861f229d1a059bb03f00ff16">stable_partition</a></code> <p>
<code>partition_copy</code> </dd></dl>

</div>
</div><p>
<a class="anchor" name="gee39ef07b42f5d17b453e409f7f9b315"></a><!-- doxytag: member="thrust::remove" ref="gee39ef07b42f5d17b453e409f7f9b315" args="(ForwardIterator first, ForwardIterator last, const T &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator, typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ForwardIterator thrust::remove           </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>remove</code> removes from the range <code>[first, last)</code> all elements that are equal to <code>value</code>. That is, <code>remove</code> returns an iterator <code>new_last</code> such that the range <code>[first, new_last)</code> contains no elements equal to <code>value</code>. The iterators in the range <code>[new_first,last)</code> are all still dereferenceable, but the elements that they point to are unspecified. <code>remove</code> is stable, meaning that the relative order of elements that are not equal to <code>value</code> is unchanged.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>The beginning of the range of interest. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>last</em>&nbsp;</td><td>The end of the range of interest. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>The value to remove from the range <code>[begin, end)</code>. Elements which are equal to value are removed from the sequence. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A <code>ForwardIterator</code> pointing to the end of the resulting range of elements which are not equal to <code>value</code>.</dd></dl>
<dl compact><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ForwardIterator</em>&nbsp;</td><td>is a model of <a href="http://www.sgi.com/tech/stl/ForwardIterator.html">Forward Iterator</a>, and <code>ForwardIterator</code> is mutable. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>T</em>&nbsp;</td><td>is a model of <a href="http://www.sgi.com/tech/stl/EqualityComparable.html">Equality Comparable</a>, and objects of type <code>T</code> can be compared for equality with objects of <code>ForwardIterator's</code> <code>value_type</code>.</td></tr>
  </table>
</dl>
The following code snippet demonstrates how to use <code>remove</code> to remove a number of interest from a range.<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;<a class="code" href="remove_8h.html" title="Defines the interface to functions for removing elements from a sequence.">thrust/remove.h</a>&gt;</span>
  ...
  <span class="keyword">const</span> <span class="keywordtype">int</span> N = 6;
  <span class="keywordtype">int</span> A[N] = {3, 1, 4, 1, 5, 9};
  <span class="keywordtype">int</span> *new_end = <a class="code" href="group__stream__compaction.html#gee39ef07b42f5d17b453e409f7f9b315">thrust::remove</a>(A, A + N, 1);
  <span class="comment">// The first four values of A are now {3, 4, 5, 9}</span>
  <span class="comment">// Values beyond new_end are unspecified</span>
</pre></div><p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The meaning of "removal" is somewhat subtle. <code>remove</code> does not destroy any iterators, and does not change the distance between <code>first</code> and <code>last</code>. (There's no way that it could do anything of the sort.) So, for example, if <code>V</code> is a <a class="el" href="classthrust_1_1device__vector.html">device_vector</a>, <code>remove(V.begin(), V.end(), 0)</code> does not change <code>V.size()</code>: <code>V</code> will contain just as many elements as it did before. <code>remove</code> returns an iterator that points to the end of the resulting range after elements have been removed from it; it follows that the elements after that iterator are of no interest, and may be discarded. If you are removing elements from a <a href="http://www.sgi.com/tech/stl/Sequence.html">Sequence</a>, you may simply erase them. That is, a reasonable way of removing elements from a <a href="http://www.sgi.com/tech/stl/Sequence.html">Sequence</a> is <code>S.erase(remove(S.begin(), S.end(), x), S.end())</code>.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a href="http://www.sgi.com/tech/stl/remove.html">http://www.sgi.com/tech/stl/remove.html</a> <p>
<a class="el" href="group__stream__compaction.html#g517b17ceafe31a9fc70ac5127bd626de">remove_if</a> <p>
<a class="el" href="group__stream__compaction.html#ge94994f9049c44a4298dcf2c6ceb2514">remove_copy</a> <p>
<a class="el" href="group__stream__compaction.html#g0dd1a702821e89b3369c7ae0d3f45af7">remove_copy_if</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="ge94994f9049c44a4298dcf2c6ceb2514"></a><!-- doxytag: member="thrust::remove_copy" ref="ge94994f9049c44a4298dcf2c6ceb2514" args="(InputIterator first, InputIterator last, OutputIterator result, const T &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator, typename OutputIterator, typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator thrust::remove_copy           </td>
          <td>(</td>
          <td class="paramtype">InputIterator&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>remove_copy</code> copies elements that are not equal to <code>value</code> from the range <code>[first, last)</code> to a range beginning at <code>result</code>. The return value is the end of the resulting range. This operation is stable, meaning that the relative order of the elements that are copied is the same as in the range <code>[first, last)</code>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>The beginning of the range of interest. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>last</em>&nbsp;</td><td>The end of the range of interest. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>The resulting range is copied to the sequence beginning at this location. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>The value to omit from the copied range. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An OutputIterator pointing to the end of the resulting range of elements which are not equal to <code>value</code>.</dd></dl>
<dl compact><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InputIterator</em>&nbsp;</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, and <code>InputIterator's</code> <code>value_type</code> is convertible to a type in <code>OutputIterator's</code> set of <code>value_types</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>OutputIterator</em>&nbsp;</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>T</em>&nbsp;</td><td>is a model of <a href="http://www.sgi.com/tech/stl/EqualityComparable">Equality Comparable</a>, and objects of type <code>T</code> can be compared for equality with objects of <code>InputIterator's</code> <code>value_type</code>.</td></tr>
  </table>
</dl>
The following code snippet demonstrates how to use <code>remove_copy</code> to copy a sequence of numbers to an output range while omitting a value of interest.<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;<a class="code" href="remove_8h.html" title="Defines the interface to functions for removing elements from a sequence.">thrust/remove.h</a>&gt;</span>
  ...
  <span class="keyword">const</span> <span class="keywordtype">int</span> N = 6;
  <span class="keywordtype">int</span> V[N] = {-2, 0, -1, 0, 1, 2};
  <span class="keywordtype">int</span> result[N-2];
  <a class="code" href="group__stream__compaction.html#ge94994f9049c44a4298dcf2c6ceb2514">thrust::remove_copy</a>(V, V + N, result, 0);
  <span class="comment">// V remains {-2, 0, -1, 0, 1, 2}</span>
  <span class="comment">// result is now {-2, -1, 1, 2}</span>
</pre></div><p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a href="http://www.sgi.com/tech/stl/remove_copy.html">http://www.sgi.com/tech/stl/remove_copy.html</a> <p>
<a class="el" href="group__stream__compaction.html#gee39ef07b42f5d17b453e409f7f9b315">remove</a> <p>
<a class="el" href="group__stream__compaction.html#g517b17ceafe31a9fc70ac5127bd626de">remove_if</a> <p>
<a class="el" href="group__stream__compaction.html#g0dd1a702821e89b3369c7ae0d3f45af7">remove_copy_if</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g0dd1a702821e89b3369c7ae0d3f45af7"></a><!-- doxytag: member="thrust::remove_copy_if" ref="g0dd1a702821e89b3369c7ae0d3f45af7" args="(InputIterator first, InputIterator last, OutputIterator result, Predicate pred)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator, typename OutputIterator, typename Predicate&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator thrust::remove_copy_if           </td>
          <td>(</td>
          <td class="paramtype">InputIterator&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&nbsp;</td>
          <td class="paramname"> <em>pred</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>remove_copy_if</code> copies elements from the range <code>[first,last)</code> to a range beginning at <code>result</code>, except that elements for which <code>pred</code> is <code>true</code> are not copied. The return value is the end of the resulting range. This operation is stable, meaning that the relative order of the elements that are copied is the same as the range <code>[first,last)</code>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>The beginning of the range of interest. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>last</em>&nbsp;</td><td>The end of the range of interest. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>The resulting range is copied to the sequence beginning at this location. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pred</em>&nbsp;</td><td>A predicate to evaluate for each element of the range <code>[first,last)</code>. Elements for which <code>pred</code> evaluates to <code>false</code> are not copied to the resulting sequence. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An OutputIterator pointing to the end of the resulting range.</dd></dl>
<dl compact><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InputIterator</em>&nbsp;</td><td>is a model of <a href="http://www.sgi.com/tech/stl/InputIterator.html">Input Iterator</a>, <code>InputIterator's</code> <code>value_type</code> is convertible to a type in <code>OutputIterator's</code> set of <code>value_types</code>, and <code>InputIterator's</code> <code>value_type</code> is convertible to <code>Predicate's</code> <code>argument_type</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>OutputIterator</em>&nbsp;</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Predicate</em>&nbsp;</td><td>is a model of <a href="http://www.sgi.com/tech/stl/Predicate.html">Predicate</a>.</td></tr>
  </table>
</dl>
The following code snippet demonstrates how to use <code>remove_copy_if</code> to copy a sequence of numbers to an output range while omitting even numbers.<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;<a class="code" href="remove_8h.html" title="Defines the interface to functions for removing elements from a sequence.">thrust/remove.h</a>&gt;</span>
  ...
  <span class="keyword">struct </span>is_even
  {
    __host__ __device__
    <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> <span class="keywordtype">int</span> x)
    {
      <span class="keywordflow">return</span> (x % 2) == 0;
    }
  };
  ...
  <span class="keyword">const</span> <span class="keywordtype">int</span> N = 6;
  <span class="keywordtype">int</span> V[N] = {-2, 0, -1, 0, 1, 2};
  <span class="keywordtype">int</span> result[2];
  <a class="code" href="group__stream__compaction.html#g0dd1a702821e89b3369c7ae0d3f45af7">thrust::remove_copy_if</a>(V, V + N, result, is_even());
  <span class="comment">// V remains {-2, 0, -1, 0, 1, 2}</span>
  <span class="comment">// result is now {-1, 1}</span>
</pre></div><p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a href="http://www.sgi.com/tech/stl/remove_copy_if.html">http://www.sgi.com/tech/stl/remove_copy_if.html</a> <p>
<a class="el" href="group__stream__compaction.html#gee39ef07b42f5d17b453e409f7f9b315">remove</a> <p>
<a class="el" href="group__stream__compaction.html#ge94994f9049c44a4298dcf2c6ceb2514">remove_copy</a> <p>
<a class="el" href="group__stream__compaction.html#g517b17ceafe31a9fc70ac5127bd626de">remove_if</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g517b17ceafe31a9fc70ac5127bd626de"></a><!-- doxytag: member="thrust::remove_if" ref="g517b17ceafe31a9fc70ac5127bd626de" args="(ForwardIterator first, ForwardIterator last, Predicate pred)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator, typename Predicate&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ForwardIterator thrust::remove_if           </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&nbsp;</td>
          <td class="paramname"> <em>pred</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>remove_if</code> removes from the range <code>[first, last)</code> every element <code>x</code> such that <code>pred(x)</code> is <code>true</code>. That is, <code>remove_if</code> returns an iterator <code>new_last</code> such that the range <code>[first,new_last)</code> contains no elements for which <code>pred</code> is <code>true</code>. The iterators in the range <code>[new_last,last)</code> are all still dereferenceable, but the elements that they point to are unspecified. <code>remove_if</code> is stable, meaning that the relative order of elements that are not removed is unchanged.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>The beginning of the range of interest. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>last</em>&nbsp;</td><td>The end of the range of interest. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pred</em>&nbsp;</td><td>A predicate to evaluate for each element of the range <code>[first,last)</code>. Elements for which <code>pred</code> evaluates to <code>false</code> are removed from the sequence. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A ForwardIterator pointing to the end of the resulting range of elements for which <code>pred</code> evaluated to <code>true</code>.</dd></dl>
<dl compact><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ForwardIterator</em>&nbsp;</td><td>is a model of <a href="http://www.sgi.com/tech/ForwardIterator.html">Forward Iterator</a>, <code>ForwardIterator</code> is mutable, and <code>ForwardIterator's</code> <code>value_type</code> is convertible to <code>Predicate's</code> <code>argument_type</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Predicate</em>&nbsp;</td><td>is a model of <a href="http://www.sgi.com/tech/Predicate.html">Predicate</a>.</td></tr>
  </table>
</dl>
The following code snippet demonstrates how to use <code>remove_if</code> to remove all even numbers from an array of integers.<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;<a class="code" href="remove_8h.html" title="Defines the interface to functions for removing elements from a sequence.">thrust/remove.h</a>&gt;</span>
  ...
  <span class="keyword">struct </span>is_even
  {
    __host__ __device__
    <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> <span class="keywordtype">int</span> x)
    {
      <span class="keywordflow">return</span> (x % 2) == 0;
    }
  };
  ...
  <span class="keyword">const</span> <span class="keywordtype">int</span> N = 6;
  <span class="keywordtype">int</span> A[N] = {1, 4, 2, 8, 5, 7};
  <span class="keywordtype">int</span> *new_end = <a class="code" href="group__stream__compaction.html#gee39ef07b42f5d17b453e409f7f9b315">thrust::remove</a>(A, A + N, is_even());
  <span class="comment">// The first three values of A are now {1, 5, 7}</span>
  <span class="comment">// Values beyond new_end are unspecified</span>
</pre></div><p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The meaning of "removal" is somewhat subtle. <code>remove_if</code> does not destroy any iterators, and does not change the distance between <code>first</code> and <code>last</code>. (There's no way that it could do anything of the sort.) So, for example, if <code>V</code> is a <a class="el" href="classthrust_1_1device__vector.html">device_vector</a>, <code>remove_if(V.begin(), V.end(), pred)</code> does not change <code>V.size()</code>: <code>V</code> will contain just as many elements as it did before. <code>remove_if</code> returns an iterator that points to the end of the resulting range after elements have been removed from it; it follows that the elements after that iterator are of no interest, and may be discarded. If you are removing elements from a <a href="http://www.sgi.com/tech/stl/Sequence.html">Sequence</a>, you may simply erase them. That is, a reasonable way of removing elements from a <a href="http://www.sgi.com/tech/stl/Sequence.html">Sequence</a> is <code>S.erase(remove_if(S.begin(), S.end(), pred), S.end())</code>.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a href="http://www.sgi.com/tech/stl/remove_if.html">http://www.sgi.com/tech/stl/remove_if.html</a> <p>
<a class="el" href="group__stream__compaction.html#gee39ef07b42f5d17b453e409f7f9b315">remove</a> <p>
<a class="el" href="group__stream__compaction.html#ge94994f9049c44a4298dcf2c6ceb2514">remove_copy</a> <p>
<a class="el" href="group__stream__compaction.html#g0dd1a702821e89b3369c7ae0d3f45af7">remove_copy_if</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="gf7f5925c861f229d1a059bb03f00ff16"></a><!-- doxytag: member="thrust::stable_partition" ref="gf7f5925c861f229d1a059bb03f00ff16" args="(ForwardIterator begin, ForwardIterator end, Predicate pred)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator, typename Predicate&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ForwardIterator thrust::stable_partition           </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&nbsp;</td>
          <td class="paramname"> <em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&nbsp;</td>
          <td class="paramname"> <em>pred</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<code>stable_partition</code> is much like <a class="el" href="group__stream__compaction.html#g0c4bd59a85f63ec0d17f579e92fc333e">partition</a> : it reorders the elements in the range <code>[begin, end)</code> based on the function object <code>pred</code>, such that all of the elements that satisfy <code>pred</code> precede all of the elements that fail to satisfy it. The postcondition is that, for some iterator <code>middle</code> in the range <code>[begin,end)</code>, <code>pred(*i)</code> is <code>true</code> for every iterator <code>i</code> in the range <code>[begin,middle)</code> and <code>false</code> for every iterator <code>i</code> in the range <code>[middle,end)</code>. The return value of <code>stable_partition</code> is <code>middle</code>.<p>
<code>stable_partition</code> differs from <a class="el" href="group__stream__compaction.html#g0c4bd59a85f63ec0d17f579e92fc333e">partition</a> in that <code>stable_partition</code> is guaranteed to preserve relative order. That is, if <code>x</code> and <code>y</code> are elements in <code>[begin,end)</code>, such that <code>pred(x) == pred(y)</code>, and if <code>x</code> precedes <code>y</code>, then it will still be true after <code>stable_partition</code> that <code>x</code> precedes <code>y</code>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>begin</em>&nbsp;</td><td>The first element of the sequence to reorder. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>One position past the last element of the sequence to reorder. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pred</em>&nbsp;</td><td>A function object which decides to which partition each element of the sequence [begin,end) belongs. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An iterator referring to the first element of the second partition, that is, the sequence of the elements which do not satisfy pred.</dd></dl>
<dl compact><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ForwardIterator</em>&nbsp;</td><td>is a model of <a href="http://www.sgi.com/tech/stl/ForwardIterator.html">Forward Iterator</a>, and <code>ForwardIterator's</code> <code>value_type</code> is convertible to <code>Predicate's</code> <code>argument_type</code>, and <code>ForwardIterator</code> is mutable. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Predicate</em>&nbsp;</td><td>is a model of <a href="http://www.sgi.com/tech/stl/Predicate.html">Predicate</a>.</td></tr>
  </table>
</dl>
The following code snippet demonstrates how to use <code>stable_partition</code> to reorder a sequence so that even numbers precede odd numbers.<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;<a class="code" href="partition_8h.html" title="Defines the interface to a function performing a stream compaction computation.">thrust/partition.h</a>&gt;</span>
  ...
  <span class="keyword">struct </span>is_even
  {
    __host__ __device__
    <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> <span class="keywordtype">int</span> &amp;x)
    {
      <span class="keywordflow">return</span> (x % 2) == 0;
    }
  };
  ...
  <span class="keywordtype">int</span> A[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
  <span class="keyword">const</span> <span class="keywordtype">int</span> N = <span class="keyword">sizeof</span>(A)/<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>);
  <a class="code" href="group__stream__compaction.html#gf7f5925c861f229d1a059bb03f00ff16">thrust::stable_partition</a>(A, A + N,
                            is_even());
  <span class="comment">// A is now {2, 4, 6, 8, 10, 1, 3, 5, 7, 9}</span>
</pre></div><p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a href="http://www.sgi.com/tech/stl/stable_partition.html">http://www.sgi.com/tech/stl/stable_partition.html</a> <p>
<code><a class="el" href="group__stream__compaction.html#g0c4bd59a85f63ec0d17f579e92fc333e">partition</a></code> <p>
<code>stable_partition_copy</code> </dd></dl>

</div>
</div><p>
<a class="anchor" name="ga213c713ba882275d7f98564528bc4ab"></a><!-- doxytag: member="thrust::unique" ref="ga213c713ba882275d7f98564528bc4ab" args="(ForwardIterator first, ForwardIterator last, BinaryPredicate binary_pred)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator, typename BinaryPredicate&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ForwardIterator thrust::unique           </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryPredicate&nbsp;</td>
          <td class="paramname"> <em>binary_pred</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
For each group of consecutive elements in the range <code>[first, last)</code> with the same value, <code>unique</code> removes all but the first element of the group. The return value is an iterator <code>new_last</code> such that no two consecutive elements in the range <code>[first, new_last)</code> are equal. The iterators in the range <code>[new_last, last)</code> are all still dereferenceable, but the elements that they point to are unspecified. <code>unique</code> is stable, meaning that the relative order of elements that are not removed is unchanged.<p>
This version of <code>unique</code> uses the function object <code>binary_pred</code> to test for equality.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>The beginning of the input range. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>last</em>&nbsp;</td><td>The end of the input range. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>binary_pred</em>&nbsp;</td><td>The binary predicate used to determine equality. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The end of the unique range <code>[first, new_last)</code></dd></dl>
<dl compact><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ForwardIterator</em>&nbsp;</td><td>is a model of <a href="http://www.sgi.com/tech/stl/ForwardIterator.html">Forward Iterator</a>, and <code>ForwardIterator</code> is mutable, and <code>ForwardIterator's</code> <code>value_type</code> is convertible to <code>BinaryPredicate's</code> <code>first_argument_type</code> and to <code>BinaryPredicate's</code> <code>second_argument_type</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BinaryPredicate</em>&nbsp;</td><td>is a model of <a href="http://www.sgi.com/tech/stl/BinaryPredicate.html">Binary Predicate</a>.</td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a href="http://www.sgi.com/tech/stl/unique.html">http://www.sgi.com/tech/stl/unique.html</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g330c12555aa9d382254c9f1296e3edcc"></a><!-- doxytag: member="thrust::unique" ref="g330c12555aa9d382254c9f1296e3edcc" args="(ForwardIterator first, ForwardIterator last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ForwardIterator thrust::unique           </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
For each group of consecutive elements in the range <code>[first, last)</code> with the same value, <code>unique</code> removes all but the first element of the group. The return value is an iterator <code>new_last</code> such that no two consecutive elements in the range <code>[first, new_last)</code> are equal. The iterators in the range <code>[new_last, last)</code> are all still dereferenceable, but the elements that they point to are unspecified. <code>unique</code> is stable, meaning that the relative order of elements that are not removed is unchanged.<p>
This version of <code>unique</code> uses <code>operator==</code> to test for equality.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>The beginning of the input range. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>last</em>&nbsp;</td><td>The end of the input range. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The end of the unique range <code>[first, new_last)</code>.</dd></dl>
<dl compact><dt><b>Template Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ForwardIterator</em>&nbsp;</td><td>is a model of <a href="http://www.sgi.com/tech/stl/ForwardIterator.html">Forward Iterator</a>, and <code>ForwardIterator</code> is mutable, and <code>ForwardIterator's</code> <code>value_type</code> is a model of <a href="http://www.sgi.com/tech/stl/EqualityComparable.html">Equality Comparable</a>.</td></tr>
  </table>
</dl>
The following code snippet demonstrates how to use <code>unique</code> to compact a sequence of numbers to remove consecutive duplicates.<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;<a class="code" href="unique_8h.html" title="Move unique elements to the front of a sequence.">thrust/unique.h</a>&gt;</span>
  ...
  <span class="keyword">const</span> <span class="keywordtype">int</span> N = 7;
  <span class="keywordtype">int</span> A[N] = {1, 3, 3, 3, 2, 2, 1};
  <span class="keywordtype">int</span> *new_end = <a class="code" href="group__stream__compaction.html#g330c12555aa9d382254c9f1296e3edcc">thrust::unique</a>(A, A + N);
  <span class="comment">// The first four values of A are now {1, 3, 2, 1}</span>
  <span class="comment">// Values beyond new_end are unspecified.</span>
</pre></div><p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a href="http://www.sgi.com/tech/stl/unique.html">http://www.sgi.com/tech/stl/unique.html</a> </dd></dl>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Tue May 26 21:09:12 2009 for thrust by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
