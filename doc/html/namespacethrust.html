<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>thrust: thrust Namespace Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="namespaces.html"><span>Namespace List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>thrust Namespace Reference</h1>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__allocator_3_01void_01_4.html">device_allocator&lt; void &gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__allocator.html">device_allocator</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__new__allocator.html">device_new_allocator</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthrust_1_1device__ptr.html">device_ptr</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthrust_1_1device__reference.html">device_reference</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html">device_vector</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthrust_1_1unary__function.html">unary_function</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthrust_1_1binary__function.html">binary_function</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthrust_1_1plus.html">plus</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthrust_1_1minus.html">minus</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthrust_1_1multiplies.html">multiplies</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthrust_1_1divides.html">divides</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthrust_1_1modulus.html">modulus</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthrust_1_1negate.html">negate</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthrust_1_1absolute__value.html">absolute_value</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthrust_1_1equal__to.html">equal_to</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthrust_1_1not__equal__to.html">not_equal_to</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthrust_1_1greater.html">greater</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthrust_1_1less.html">less</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthrust_1_1greater__equal.html">greater_equal</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthrust_1_1less__equal.html">less_equal</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthrust_1_1logical__and.html">logical_and</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthrust_1_1logical__or.html">logical_or</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthrust_1_1logical__not.html">logical_not</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthrust_1_1identity.html">identity</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthrust_1_1maximum.html">maximum</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthrust_1_1minimum.html">minimum</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthrust_1_1unary__negate.html">unary_negate</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthrust_1_1binary__negate.html">binary_negate</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1host__vector.html">host_vector</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthrust_1_1input__device__iterator__tag.html">input_device_iterator_tag</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthrust_1_1output__device__iterator__tag.html">output_device_iterator_tag</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthrust_1_1forward__device__iterator__tag.html">forward_device_iterator_tag</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthrust_1_1bidirectional__device__iterator__tag.html">bidirectional_device_iterator_tag</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthrust_1_1random__access__device__iterator__tag.html">random_access_device_iterator_tag</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>iterator_traits</b></td></tr>

<tr><td colspan="2"><br><h2>Namespaces</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacethrust_1_1experimental.html">experimental</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacethrust_1_1sorting.html">sorting</a></td></tr>

<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::input_iterator_tag&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iterator__tag__classes.html#g9c81b5a0793b7ab5164138cf90bc4467">input_host_iterator_tag</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::output_iterator_tag&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iterator__tag__classes.html#g1a68f19231a55966d6ccbbeb0143fc78">output_host_iterator_tag</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::forward_iterator_tag&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iterator__tag__classes.html#g3e917ce7912b40457dc8bf8eac3f63c4">forward_host_iterator_tag</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <br>
std::bidirectional_iterator_tag&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iterator__tag__classes.html#g4fc4cba5e02678c694d1e2c38ecc97ac">bidirectional_host_iterator_tag</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <br>
std::random_access_iterator_tag&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iterator__tag__classes.html#g80a4b8250e3322344767a6b417e72256">random_access_host_iterator_tag</a></td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator, typename OutputIterator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">OutputIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transformations.html#g7a4ecc0deca6892ee7ed8676a62a9e0a">adjacent_difference</a> (InputIterator first, InputIterator last, OutputIterator result)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator, typename OutputIterator, typename BinaryFunction&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">OutputIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transformations.html#g02e643b9418679ab0aac88651965f781">adjacent_difference</a> (InputIterator first, InputIterator last, OutputIterator result, BinaryFunction binary_op)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator, typename OutputIterator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">OutputIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__regular__copying.html#g6e123c4508ed48ce98e79f4679c1aac2">copy</a> (InputIterator first, InputIterator last, OutputIterator result)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator, typename PredicateIterator, typename OutputIterator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">OutputIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__regular__copying.html#geaea5f99daffdbdc24781c478f79e468">copy_when</a> (InputIterator first, InputIterator last, PredicateIterator stencil, OutputIterator result)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator, typename PredicateIterator, typename OutputIterator, typename Predicate&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">OutputIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__regular__copying.html#gda759ca469bce32b1bdd5b0d3509863d">copy_when</a> (InputIterator begin, InputIterator end, PredicateIterator stencil, OutputIterator result, Predicate pred)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class InputIterator, class EqualityComparable&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">thrust::iterator_traits<br>
&lt; InputIterator &gt;<br>
::difference_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__counting.html#ged7430565cd9d714515b659075964de1">count</a> (InputIterator first, InputIterator last, const EqualityComparable &amp;value)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class InputIterator, class Predicate&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">thrust::iterator_traits<br>
&lt; InputIterator &gt;<br>
::difference_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__counting.html#g3726ca0c8fb6becc2c5a6744414859fe">count_if</a> (InputIterator first, InputIterator last, Predicate pred)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__deallocation__functions.html#g7fa26a9a34d9fd326b31139db16ea997">device_delete</a> (<a class="el" href="structthrust_1_1device__ptr.html">thrust::device_ptr</a>&lt; T &gt; ptr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__deallocation__functions.html#g1a350740a6ade432f3781096df91f162">device_free</a> (<a class="el" href="structthrust_1_1device__ptr.html">thrust::device_ptr</a>&lt; void &gt; ptr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structthrust_1_1device__ptr.html">thrust::device_ptr</a>&lt; void &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__allocation__functions.html#g10fcbe2b7caeb26a4bea365c297648d4">device_malloc</a> (const std::size_t n)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structthrust_1_1device__ptr.html">device_ptr</a>&lt; T &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__allocation__functions.html#g4c8a057314da6f7dab0b471f5b726247">device_new</a> (<a class="el" href="structthrust_1_1device__ptr.html">device_ptr</a>&lt; void &gt; p, const size_t n=1)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structthrust_1_1device__ptr.html">device_ptr</a>&lt; T &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__allocation__functions.html#g0fa58b4eeeb26187d60af1d68bfc2e8e">device_new</a> (<a class="el" href="structthrust_1_1device__ptr.html">device_ptr</a>&lt; void &gt; p, const T &amp;exemplar, const size_t n=1)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structthrust_1_1device__ptr.html">device_ptr</a>&lt; T &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__allocation__functions.html#gfcea8c22c0b3e98bd4567ec65b96dfc3">device_new</a> (const size_t n=1)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, typename T2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">__host__ __device__ bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory__management__classes.html#gc4f18e7a235074671b89cde1a7b6a216">operator==</a> (const <a class="el" href="structthrust_1_1device__ptr.html">device_ptr</a>&lt; T1 &gt; &amp;lhs, const <a class="el" href="structthrust_1_1device__ptr.html">device_ptr</a>&lt; T2 &gt; &amp;rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, typename T2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">__host__ __device__ bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory__management__classes.html#ga38aa86e2419695cb169a7d48bf52037">operator!=</a> (const <a class="el" href="structthrust_1_1device__ptr.html">device_ptr</a>&lt; T1 &gt; &amp;lhs, const <a class="el" href="structthrust_1_1device__ptr.html">device_ptr</a>&lt; T2 &gt; &amp;rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, typename T2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">__host__ __device__ bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory__management__classes.html#gae33dbdd27fb941c1daf830976b392eb">operator&lt;</a> (const <a class="el" href="structthrust_1_1device__ptr.html">device_ptr</a>&lt; T1 &gt; &amp;lhs, const <a class="el" href="structthrust_1_1device__ptr.html">device_ptr</a>&lt; T2 &gt; &amp;rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, typename T2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">__host__ __device__ bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory__management__classes.html#g3e8790abd0deddb19468287fe4a051fc">operator&lt;=</a> (const <a class="el" href="structthrust_1_1device__ptr.html">device_ptr</a>&lt; T1 &gt; &amp;lhs, const <a class="el" href="structthrust_1_1device__ptr.html">device_ptr</a>&lt; T2 &gt; &amp;rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, typename T2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">__host__ __device__ bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory__management__classes.html#g12855630011bf452950b533f0aa6d0e4">operator&gt;</a> (const <a class="el" href="structthrust_1_1device__ptr.html">device_ptr</a>&lt; T1 &gt; &amp;lhs, const <a class="el" href="structthrust_1_1device__ptr.html">device_ptr</a>&lt; T2 &gt; &amp;rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, typename T2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">__host__ __device__ bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory__management__classes.html#g8f1a4076dfc2684ea9f81e7039f01cc0">operator&gt;=</a> (const <a class="el" href="structthrust_1_1device__ptr.html">device_ptr</a>&lt; T1 &gt; &amp;lhs, const <a class="el" href="structthrust_1_1device__ptr.html">device_ptr</a>&lt; T2 &gt; &amp;rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class E, class T, class Y&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::basic_ostream&lt; E, T &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory__management__classes.html#g901cb64f4bfc3cce0d217e741c45fdc4">operator&lt;&lt;</a> (std::basic_ostream&lt; E, T &gt; &amp;os, const <a class="el" href="structthrust_1_1device__ptr.html">device_ptr</a>&lt; Y &gt; &amp;p)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">__host__ __device__ <a class="el" href="structthrust_1_1device__ptr.html">device_ptr</a>&lt; T &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory__management__functions.html#ge76e0501378683b1484d9797e8c327c6">device_pointer_cast</a> (T *ptr)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">__host__ __device__ <a class="el" href="structthrust_1_1device__ptr.html">device_ptr</a>&lt; T &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory__management__functions.html#g33a97359089a2dc3b7f42b38ddfba2b3">device_pointer_cast</a> (const <a class="el" href="structthrust_1_1device__ptr.html">device_ptr</a>&lt; T &gt; &amp;ptr)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">__host__ __device__ T *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory__management__functions.html#gdaa845eb24daf3fd7c42dfa3cd06296b">raw_pointer_cast</a> (const <a class="el" href="structthrust_1_1device__ptr.html">device_ptr</a>&lt; T &gt; &amp;ptr)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">__host__ __device__ T *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory__management__functions.html#gdebed21f24bd0e104c1416c1af7dc16f">raw_pointer_cast</a> (T *ptr)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, typename Alloc1, typename T2, typename Alloc2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__device__containers.html#g70d776486d6553bc83f0f7d23e81119f">operator==</a> (const <a class="el" href="classthrust_1_1device__vector.html">device_vector</a>&lt; T1, Alloc1 &gt; &amp;lhs, const <a class="el" href="classthrust_1_1device__vector.html">device_vector</a>&lt; T2, Alloc2 &gt; &amp;rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, typename Alloc1, typename T2, typename Alloc2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__device__containers.html#gdfbb25f3872863a405462e68bced0920">operator==</a> (const <a class="el" href="classthrust_1_1host__vector.html">host_vector</a>&lt; T1, Alloc1 &gt; &amp;lhs, const <a class="el" href="classthrust_1_1device__vector.html">device_vector</a>&lt; T2, Alloc2 &gt; &amp;rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, typename Alloc1, typename T2, typename Alloc2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__device__containers.html#ge9453079557d9fb85feb9ba06919373b">operator==</a> (const <a class="el" href="classthrust_1_1device__vector.html">device_vector</a>&lt; T1, Alloc1 &gt; &amp;lhs, const <a class="el" href="classthrust_1_1host__vector.html">host_vector</a>&lt; T2, Alloc2 &gt; &amp;rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, typename Alloc1, typename T2, typename Alloc2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__device__containers.html#g362e92f861818da9715d8bf35541e6c1">operator==</a> (const std::vector&lt; T1, Alloc1 &gt; &amp;lhs, const <a class="el" href="classthrust_1_1device__vector.html">device_vector</a>&lt; T2, Alloc2 &gt; &amp;rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, typename Alloc1, typename T2, typename Alloc2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__device__containers.html#g1a0c8a5f9542a8a8efecd3b54a8a1bb2">operator==</a> (const <a class="el" href="classthrust_1_1device__vector.html">device_vector</a>&lt; T1, Alloc1 &gt; &amp;lhs, const std::vector&lt; T2, Alloc2 &gt; &amp;rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">thrust::iterator_traits<br>
&lt; InputIterator &gt;<br>
::difference_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__counting.html#g7aca72a5d6db68ff8d58407f57ebfd5b">distance</a> (InputIterator first, InputIterator last)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator1, typename InputIterator2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__comparisons.html#g3282d7cca489b11517873c1b632add6e">equal</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator1, typename InputIterator2, typename BinaryPredicate&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__comparisons.html#g02e74f1fc5f8f9e88cf8c7aa38f45dab">equal</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, BinaryPredicate binary_pred)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T, typename BinaryPredicate&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">__host__ __device__ T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrust.html#efe61bcc73a9bb0c52e82ae5683450fb">min</a> (const T &amp;lhs, const T &amp;rhs, BinaryPredicate comp)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">__host__ __device__ T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrust.html#62a2248e1ae6b1c4c7f05fe2110642da">min</a> (const T &amp;lhs, const T &amp;rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T, typename BinaryPredicate&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">__host__ __device__ T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrust.html#6224f2e380580660689881ce36c942dc">max</a> (const T &amp;lhs, const T &amp;rhs, BinaryPredicate comp)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">__host__ __device__ T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrust.html#6494be22a814fb21a363e5963df1bbdc">max</a> (const T &amp;lhs, const T &amp;rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ForwardIterator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">ForwardIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__extrema.html#g1062ee9c61ace34b724e141f85e79999">min_element</a> (ForwardIterator first, ForwardIterator last)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ForwardIterator, typename BinaryPredicate&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">ForwardIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__extrema.html#g1fa9b9c2deff94b0b251b0c74bddf878">min_element</a> (ForwardIterator first, ForwardIterator last, BinaryPredicate comp)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ForwardIterator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">ForwardIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__extrema.html#g06e155dabb91848ffd1c5725f8e0ce14">max_element</a> (ForwardIterator first, ForwardIterator last)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ForwardIterator, typename BinaryPredicate&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">ForwardIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__extrema.html#g15bc459d66e289d99a789b99594f7339">max_element</a> (ForwardIterator first, ForwardIterator last, BinaryPredicate comp)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ForwardIterator, typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__filling.html#gc8bd6f546d43f61fcbcacd789103448d">fill</a> (ForwardIterator first, ForwardIterator last, const T &amp;value)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator, typename UnaryFunction&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__parallelization.html#gb46ff872f1d9a086691a76d08ba5e47c">for_each</a> (InputIterator first, InputIterator last, UnaryFunction f)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Predicate&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">__host__ __device__ <br>
<a class="el" href="structthrust_1_1unary__negate.html">unary_negate</a>&lt; Predicate &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__function__object__adaptors.html#g6b91d8a861a2c856dc2b1078f2b3e0e3">not1</a> (Predicate &amp;pred)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename BinaryPredicate&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">__host__ __device__ <br>
<a class="el" href="structthrust_1_1binary__negate.html">binary_negate</a>&lt; BinaryPredicate &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__function__object__adaptors.html#g50bea5bb8a4d58d5d86e2936647a1f88">not2</a> (BinaryPredicate &amp;pred)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ForwardIterator, typename InputIterator, typename RandomAccessIterator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__irregular__copying.html#g3a04c5863e2c1d39b84031caa3acfc5a">gather</a> (ForwardIterator first, ForwardIterator last, InputIterator map, RandomAccessIterator input)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ForwardIterator, typename InputIterator1, typename InputIterator2, typename RandomAccessIterator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__irregular__copying.html#g6cef73cd2efd4cc006a625e49aac42e8">gather_if</a> (ForwardIterator first, ForwardIterator last, InputIterator1 map, InputIterator2 stencil, RandomAccessIterator input)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ForwardIterator, typename InputIterator1, typename InputIterator2, typename RandomAccessIterator, typename Predicate&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__irregular__copying.html#gf7bc2b951ef0c0ac403a97f092c575ac">gather_if</a> (ForwardIterator first, ForwardIterator last, InputIterator1 map, InputIterator2 stencil, RandomAccessIterator input, Predicate pred)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ForwardIterator, typename Generator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transformations.html#gd5f3c63fe57a75d03a731d0cd824e3e2">generate</a> (ForwardIterator first, ForwardIterator last, Generator gen)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, typename Alloc1, typename T2, typename Alloc2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__host__containers.html#g87027c1fd97ec2ca0f7a3e530bd729e4">operator==</a> (const <a class="el" href="classthrust_1_1host__vector.html">host_vector</a>&lt; T1, Alloc1 &gt; &amp;lhs, const <a class="el" href="classthrust_1_1host__vector.html">host_vector</a>&lt; T2, Alloc2 &gt; &amp;rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, typename Alloc1, typename T2, typename Alloc2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__host__containers.html#g7841c27afe1244b39552cf3c0f77d7f0">operator==</a> (const <a class="el" href="classthrust_1_1host__vector.html">host_vector</a>&lt; T1, Alloc1 &gt; &amp;lhs, const std::vector&lt; T2, Alloc2 &gt; &amp;rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, typename Alloc1, typename T2, typename Alloc2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__host__containers.html#g14e7289d1e9a7339558e7cfb12f2f765">operator==</a> (const std::vector&lt; T1, Alloc1 &gt; &amp;lhs, const <a class="el" href="classthrust_1_1host__vector.html">host_vector</a>&lt; T2, Alloc2 &gt; &amp;rhs)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator1, typename InputIterator2, typename OutputType&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">OutputType&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transformed__reductions.html#gff95eb23b4fb99f7a873c1471c0a75c6">inner_product</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputType init)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator1, typename InputIterator2, typename OutputType, typename BinaryFunction1, typename BinaryFunction2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">OutputType&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transformed__reductions.html#g8fcc4e5a71e784f1f32af89ab5a42e35">inner_product</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputType init, BinaryFunction1 binary_op1, BinaryFunction2 binary_op2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ForwardIterator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__predicates.html#gdb8e5879d64546addb3b252c214e3bea">is_sorted</a> (ForwardIterator first, ForwardIterator last)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ForwardIterator, typename StrictWeakOrdering&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__predicates.html#g2eb711e243aae346c3145c17c8fbdd12">is_sorted</a> (ForwardIterator first, ForwardIterator last, StrictWeakOrdering comp)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ForwardIterator, typename Predicate&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">ForwardIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stream__compaction.html#g0c4bd59a85f63ec0d17f579e92fc333e">partition</a> (ForwardIterator first, ForwardIterator last, Predicate pred)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ForwardIterator, typename Predicate&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">ForwardIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stream__compaction.html#gf7f5925c861f229d1a059bb03f00ff16">stable_partition</a> (ForwardIterator begin, ForwardIterator end, Predicate pred)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">thrust::iterator_traits<br>
&lt; InputIterator &gt;::value_type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__reductions.html#gcf5a4b246454d2aa0d91cda1bb93d0c2">reduce</a> (InputIterator first, InputIterator last)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator, typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__reductions.html#g4e625915bd37ea94d2fdf7cd9637f350">reduce</a> (InputIterator first, InputIterator last, T init)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator, typename T, typename BinaryFunction&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__reductions.html#g268b8b31c9c3a2e6e4b3b6be1f5c202d">reduce</a> (InputIterator first, InputIterator last, T init, BinaryFunction binary_op)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ForwardIterator, typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">ForwardIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stream__compaction.html#gee39ef07b42f5d17b453e409f7f9b315">remove</a> (ForwardIterator first, ForwardIterator last, const T &amp;value)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator, typename OutputIterator, typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">OutputIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stream__compaction.html#ge94994f9049c44a4298dcf2c6ceb2514">remove_copy</a> (InputIterator first, InputIterator last, OutputIterator result, const T &amp;value)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ForwardIterator, typename Predicate&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">ForwardIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stream__compaction.html#g517b17ceafe31a9fc70ac5127bd626de">remove_if</a> (ForwardIterator first, ForwardIterator last, Predicate pred)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator, typename OutputIterator, typename Predicate&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">OutputIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stream__compaction.html#g0dd1a702821e89b3369c7ae0d3f45af7">remove_copy_if</a> (InputIterator first, InputIterator last, OutputIterator result, Predicate pred)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ForwardIterator, typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__replacing.html#g82185290785dc3e4d090e6ac4a9a6a98">replace</a> (ForwardIterator first, ForwardIterator last, const T &amp;old_value, const T &amp;new_value)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ForwardIterator, typename Predicate, typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__replacing.html#g3c90447007bf72cd99168d1f99c6794d">replace_if</a> (ForwardIterator first, ForwardIterator last, Predicate pred, const T &amp;new_value)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ForwardIterator, typename InputIterator, typename Predicate, typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__replacing.html#gf471914d5e928de1f2b52df5e0bbf7b7">replace_if</a> (ForwardIterator first, ForwardIterator last, InputIterator stencil, Predicate pred, const T &amp;new_value)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator, typename OutputIterator, typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">OutputIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__replacing.html#g4a70cf0046bce92d6ba8b255ad724aec">replace_copy</a> (InputIterator first, InputIterator last, OutputIterator result, const T &amp;old_value, const T &amp;new_value)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator, typename OutputIterator, typename Predicate, typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">OutputIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__replacing.html#gaec29c3fdecb51cb8af5399fd2e86927">replace_copy_if</a> (InputIterator first, InputIterator last, OutputIterator result, Predicate pred, const T &amp;new_value)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator1, typename InputIterator2, typename OutputIterator, typename Predicate, typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">OutputIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__replacing.html#g517f03a30b63d8934f143dfedb437a9e">replace_copy_if</a> (InputIterator1 first, InputIterator1 last, InputIterator2 stencil, OutputIterator result, Predicate pred, const T &amp;new_value)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator, typename OutputIterator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prefixsums.html#g4c0be720466da077c8c5147f4f3dbd36">inclusive_scan</a> (InputIterator first, InputIterator last, OutputIterator result)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator, typename OutputIterator, typename AssociativeOperator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prefixsums.html#g1f2f142bd73ea1d90d58bd1cebd9e432">inclusive_scan</a> (InputIterator first, InputIterator last, OutputIterator result, AssociativeOperator binary_op)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator, typename OutputIterator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prefixsums.html#gaa38ccbe816d74aca519fa26b7a4128d">exclusive_scan</a> (InputIterator first, InputIterator last, OutputIterator result)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator, typename OutputIterator, typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prefixsums.html#g5bccdcacec00d48f6dbdc8e113770499">exclusive_scan</a> (InputIterator first, InputIterator last, OutputIterator result, const T init)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator, typename OutputIterator, typename T, typename AssociativeOperator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prefixsums.html#g68240d71e0e31fd1144fee8cae0bd1e7">exclusive_scan</a> (InputIterator first, InputIterator last, OutputIterator result, const T init, AssociativeOperator binary_op)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator1, typename InputIterator2, typename RandomAccessIterator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__irregular__copying.html#gbb4ac574e2d294dcc86e9b2bf673a5bc">scatter</a> (InputIterator1 first, InputIterator1 last, InputIterator2 map, RandomAccessIterator output)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator1, typename InputIterator2, typename InputIterator3, typename RandomAccessIterator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__irregular__copying.html#g1079bc05bcb3d4b5080f1e07444fee37">scatter_if</a> (InputIterator1 first, InputIterator1 last, InputIterator2 map, InputIterator3 stencil, RandomAccessIterator output)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator1, typename InputIterator2, typename InputIterator3, typename RandomAccessIterator, typename Predicate&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__irregular__copying.html#g327f4705e6874c2b35a3f5b4be33d6f9">scatter_if</a> (InputIterator1 first, InputIterator1 last, InputIterator2 map, InputIterator3 stencil, RandomAccessIterator output, Predicate pred)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ForwardIterator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transformations.html#g9cd45aa1d54c460639a56a02bc519a6c">sequence</a> (ForwardIterator first, ForwardIterator last)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ForwardIterator, typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transformations.html#gca02e6edc478b671a21553ee4ca74390">sequence</a> (ForwardIterator first, ForwardIterator last, T init)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ForwardIterator, typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transformations.html#g6a0f1bee86020ea06e3a278956955041">sequence</a> (ForwardIterator first, ForwardIterator last, T init, T step)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename RandomAccessIterator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__key__sorting.html#g8fd4df95e8e16c89ff92737947daa1f9">sort</a> (RandomAccessIterator first, RandomAccessIterator last)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename RandomAccessIterator, typename StrictWeakOrdering&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__key__sorting.html#g3d4da007a8ae4fb2d5b1c4d5a28a6cdb">sort</a> (RandomAccessIterator first, RandomAccessIterator last, StrictWeakOrdering comp)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename RandomAccessIterator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__key__sorting.html#g6a7930fcd6bbd0ede72c4cf10f19b75e">stable_sort</a> (RandomAccessIterator first, RandomAccessIterator last)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename RandomAccessIterator, typename StrictWeakOrdering&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__key__sorting.html#gf4beb502c75e1dead41b5a7ada46dc5c">stable_sort</a> (RandomAccessIterator first, RandomAccessIterator last, StrictWeakOrdering comp)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename RandomAccessIterator1, typename RandomAccessIterator2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__key__value__sorting.html#g5674c04d54eafefb130941d387db46e8">sort_by_key</a> (RandomAccessIterator1 keys_first, RandomAccessIterator1 keys_last, RandomAccessIterator2 values_first)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename RandomAccessKeyIterator, typename RandomAccessValueIterator, typename StrictWeakOrdering&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__key__value__sorting.html#g311d2820010df26f8e3294739c54afbc">sort_by_key</a> (RandomAccessKeyIterator keys_first, RandomAccessKeyIterator keys_last, RandomAccessValueIterator values_first, StrictWeakOrdering comp)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename RandomAccessKeyIterator, typename RandomAccessValueIterator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__key__value__sorting.html#gacaaeef071dbec7a135c4e3808b3b23c">stable_sort_by_key</a> (RandomAccessKeyIterator keys_first, RandomAccessKeyIterator keys_last, RandomAccessValueIterator values_first)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename RandomAccessKeyIterator, typename RandomAccessValueIterator, typename StrictWeakOrdering&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__key__value__sorting.html#g89e923ef0cd317c938e6801f9e2ecd88">stable_sort_by_key</a> (RandomAccessKeyIterator keys_first, RandomAccessKeyIterator keys_last, RandomAccessValueIterator values_first, StrictWeakOrdering comp)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ForwardIterator1, typename ForwardIterator2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">ForwardIterator2&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__regular__copying.html#g926a4031b491e798a1dec97e47130eac">swap_ranges</a> (ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator, typename OutputIterator, typename UnaryFunction&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">OutputIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transformations.html#g8dfab5757fde90225f5157ded26fc972">transform</a> (InputIterator first, InputIterator last, OutputIterator result, UnaryFunction op)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator1, typename InputIterator2, typename OutputIterator, typename BinaryFunction&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">OutputIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transformations.html#ga1a7f2a2a6b01891e5ca6b6380409cf8">transform</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, BinaryFunction op)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator1, typename InputIterator2, typename ForwardIterator, typename UnaryFunction, typename Predicate&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">ForwardIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transformations.html#g0c6d919392b64d22d96ac31a51797c58">transform_if</a> (InputIterator1 first, InputIterator1 last, InputIterator2 stencil, ForwardIterator result, UnaryFunction op, Predicate pred)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator1, typename InputIterator2, typename InputIterator3, typename ForwardIterator, typename BinaryFunction, typename Predicate&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">ForwardIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transformations.html#g2b07e614bfd70cf8dee15b9a1f0f9e8c">transform_if</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator3 stencil, ForwardIterator result, BinaryFunction binary_op, Predicate pred)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator, typename UnaryFunction, typename OutputType, typename BinaryFunction&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">OutputType&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transformed__reductions.html#g7b5bccf4541441517621fa5e4ffce12d">transform_reduce</a> (InputIterator begin, InputIterator end, UnaryFunction unary_op, OutputType init, BinaryFunction binary_op)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator, typename OutputIterator, typename UnaryFunction, typename AssociativeOperator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transformed__prefixsums.html#gdf18d3283ff25a585043d528066c3e49">transform_inclusive_scan</a> (InputIterator first, InputIterator last, OutputIterator result, UnaryFunction unary_op, AssociativeOperator binary_op)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator, typename OutputIterator, typename UnaryFunction, typename T, typename AssociativeOperator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transformed__prefixsums.html#g6a1e343063beaab17735163e2852da0f">transform_exclusive_scan</a> (InputIterator first, InputIterator last, OutputIterator result, UnaryFunction unary_op, T init, AssociativeOperator binary_op)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename InputIterator, typename ForwardIterator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">ForwardIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__regular__copying.html#gb4cbaf418d3e7c83f5f21781ef28b2ef">uninitialized_copy</a> (InputIterator first, InputIterator last, ForwardIterator result)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ForwardIterator, typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__filling.html#g88a213cd2dd7ceabd528ceb99bbe953b">uninitialized_fill</a> (ForwardIterator first, ForwardIterator last, const T &amp;x)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ForwardIterator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">ForwardIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stream__compaction.html#g330c12555aa9d382254c9f1296e3edcc">unique</a> (ForwardIterator first, ForwardIterator last)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename ForwardIterator, typename BinaryPredicate&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">ForwardIterator&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stream__compaction.html#ga213c713ba882275d7f98564528bc4ab">unique</a> (ForwardIterator first, ForwardIterator last, BinaryPredicate binary_pred)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Assignable1, typename Assignable2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">__host__ __device__ void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility.html#g0b13767b0d315633fd0e169028a80003">swap</a> (Assignable1 &amp;a, Assignable2 &amp;b)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
dummy comment here so namespace thrust's documentation will be extracted <hr><h2>Function Documentation</h2>
<a class="anchor" name="6494be22a814fb21a363e5963df1bbdc"></a><!-- doxytag: member="thrust::max" ref="6494be22a814fb21a363e5963df1bbdc" args="(const T &amp;lhs, const T &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ T thrust::max           </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b><a class="el" href="bug.html#_bug000009">Bug:</a></b></dt><dd>The correct form of max does not compile: const T &amp;<a class="el" href="namespacethrust.html#6494be22a814fb21a363e5963df1bbdc">max(const T &amp;lhs, const T &amp;rhs)</a>; </dd></dl>

</div>
</div><p>
<a class="anchor" name="6224f2e380580660689881ce36c942dc"></a><!-- doxytag: member="thrust::max" ref="6224f2e380580660689881ce36c942dc" args="(const T &amp;lhs, const T &amp;rhs, BinaryPredicate comp)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename BinaryPredicate&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ T thrust::max           </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryPredicate&nbsp;</td>
          <td class="paramname"> <em>comp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b><a class="el" href="bug.html#_bug000008">Bug:</a></b></dt><dd>The correct form of max does not compile: const T &amp;<a class="el" href="namespacethrust.html#6224f2e380580660689881ce36c942dc">max(const T &amp;lhs, const T &amp;rhs, BinaryPredicate comp)</a>; </dd></dl>

</div>
</div><p>
<a class="anchor" name="62a2248e1ae6b1c4c7f05fe2110642da"></a><!-- doxytag: member="thrust::min" ref="62a2248e1ae6b1c4c7f05fe2110642da" args="(const T &amp;lhs, const T &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ T thrust::min           </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b><a class="el" href="bug.html#_bug000007">Bug:</a></b></dt><dd>The correct form of min does not compile: const T &amp;<a class="el" href="namespacethrust.html#62a2248e1ae6b1c4c7f05fe2110642da">min(const T &amp;lhs, const T &amp;rhs)</a>; </dd></dl>

</div>
</div><p>
<a class="anchor" name="efe61bcc73a9bb0c52e82ae5683450fb"></a><!-- doxytag: member="thrust::min" ref="efe61bcc73a9bb0c52e82ae5683450fb" args="(const T &amp;lhs, const T &amp;rhs, BinaryPredicate comp)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename BinaryPredicate&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ T thrust::min           </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryPredicate&nbsp;</td>
          <td class="paramname"> <em>comp</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b><a class="el" href="bug.html#_bug000006">Bug:</a></b></dt><dd>The correct form of min does not compile: const T &amp;<a class="el" href="namespacethrust.html#efe61bcc73a9bb0c52e82ae5683450fb">min(const T &amp;lhs, const T &amp;rhs, BinaryPredicate comp)</a>; </dd></dl>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Tue May 26 21:09:12 2009 for thrust by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
